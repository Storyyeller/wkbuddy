<html>
    <meta charset="utf-8">
    <head>
        <title>Daily summary</title>
        <h2>Daily summary</h2>
    </head>
    <body>
        <form id="key-input-form" hidden>
            <label>Please enter your Wanikani APIv2 key:<br>
                <input id="key-input" type=text
                    pattern="[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}"
                    placeholder="01234567-89ab-cdef-0123-456789abcdef" required>
            </label>
            <input type=submit value="Calculate">
        </form>
        <pre id="progress" hidden>Loading data: </pre>
        <pre id="results"></pre>
    </body>
</html>

<script src="storage_wrapper.js"></script>


<script type="text/javascript">
'use strict';
const {log, error, trace, assert} = console;


fetch_data(['assignments', 'reviews']).then(
    res => processPage(...res)
).catch(e => {
    error('Caught error', e);
    progress.textContent = 'Oh dear, an error has occured!';
    progress.hidden = false;
});


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
let M = null;
function processPage(assignments, reviews) {
    M = {assignments, reviews};
    const assigns = [...assignments.values()].filter(a => !a.hidden);

    // Get set of previously burned subjects
    const prevburned_set = new Set(assigns.filter(r => r.resurrected_at).map(r => r.subject_id));

    // Review stats for the last 20 hours
    const day_agp = new Date((new Date).getTime() - 1000*60*60*20).toISOString();
    const now = new Date().toISOString();

    let total = 0;
    let total_correct = 0;
    let prevburned = 0;
    let prevburned_correct = 0;

    for (const [id, data] of reviews) {
        if (data.created_at < day_agp) {continue}
        const correct = !(data.incorrect_reading_answers + data.incorrect_meaning_answers);

        total++;
        if (correct) {
            total_correct++;
        }
        if (prevburned_set.has(data.subject_id)) {
            prevburned++;
            if (correct) {
                prevburned_correct++;
            }
        }
    }


    // Bucket counts (apprentice, guru, etc.)
    const counts = [0,0,0,0,0,0,0,0,0,0];
    for (const {srs_stage} of assigns) {
        counts[srs_stage]++;
    }
    const review_count = assigns.filter(a => a.available_at && a.available_at <= now).length;

    const out = document.getElementById('results');
    const write = s => out.appendChild(document.createTextNode(s));

    write(`\n${(new Date).toDateString()}:`);
    write(`\nTime spent: ---`);
    write(`\nReviews completed: ${total}`);
    write(`\nReviews remaining: ${review_count}`);
    if (total) {
        write(`\nAccuracy: ${(100*total_correct/total).toFixed(2)}% (${total_correct}/${total})`);
    }
    if (prevburned) {
        write(`\nAccuracy on resurrected items: ${(100*prevburned_correct/prevburned).toFixed(2)}% (${prevburned_correct}/${prevburned})`);
        if (prevburned < total) {
            write(`\nAccuracy on non-resurrected items: ${(100*(total_correct - prevburned_correct)/(total - prevburned)).toFixed(2)}% (${total_correct - prevburned_correct}/${total - prevburned})`);
        }
    }

    const apprentice = counts[1] + counts[2] + counts[3] + counts[4];
    const guru = counts[5] + counts[6];
    write(`\n\nCurrent item counts:`);
    write(`\nApprentice: ${apprentice}\nGuru: ${guru}\nMaster: ${counts[7]}\nEnlightened: ${counts[8]}\nBurned ${counts[9]}`);

}
</script>
