<html>
    <meta charset="utf-8">
    <head>
        <title>Wanikani review accuracy by SRS stage</title>
        <h2>Wanikani review accuracy by SRS stage</h2>
    </head>
    <body>
        <form id="key-input-form">
            <label>Enter your Wanikani APIv2 key:<br>
                <input id="key-input" type=text
                    pattern="[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}"
                    placeholder="01234567-89ab-cdef-0123-456789abcdef" required>
            </label>
            <input type=submit value="Calculate">
        </form>

        <pre id="progress" hidden>Loading data: </pre>
        <pre id="results"></pre>
    </body>
</html>

<script type="text/javascript">
'use strict';
const {log, error, trace, assert} = console;
const progress = document.getElementById('progress');


function append_progress(s) {
    progress.appendChild(document.createTextNode(s));
}

function query(key, endpoint) {
    const url = 'https://api.wanikani.com/v2/' + endpoint;
    console.log(`Fetching ${url}...`);
    return fetch(url, {
            headers: new Headers({Authorization: 'Bearer ' + key}),
            mode: 'cors',
        }).then(r => r.json());
}

async function query_all(key, endpoint) {
    const data = [];

    let res = await query(key, endpoint);
    append_progress('+');
    while (res.pages.next_url) {
        data.push(...res.data);

        const url = res.pages.next_url.split('v2/')[1];
        res = await query(key, url);
        append_progress('+');
    }
    data.push(...res.data);
    return data;
}


const VERSION = 1;
const META_KEY = 'last-updated';

function open_db(name) {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(name, VERSION);
        req.onerror = reject;
        req.onupgradeneeded = e => {
            log('open req upgrade needed', e);
            const db = e.target.result;
            console.log(db.name, db.version, db.objectStoreNames);
            for (const name of db.objectStoreNames) {db.deleteObjectStore(name);}

            console.log(db.name, db.version, db.objectStoreNames);
            for (const table of 'reviews subjects'.split(' ')) {
                db.createObjectStore(table, {keyPath: 'id'});
                db.createObjectStore(table + '-meta');
            }
            console.log(db.name, db.version, db.objectStoreNames);
        };
        req.onsuccess = e => {
            log('open req success', e);
            const db = e.target.result;
            assert(db);
            resolve(db);
        };
    });
}
function idbreq(objs, method, ...args) {
    return new Promise((resolve, reject) => {
        const req = objs[method](...args);
        req.onsuccess = e => resolve(req.result);
        req.onerror = e => reject(req.error);
    });
}
async function get_cached(db, table, fetch_cb) {
    const main_name = table;
    const meta_name = table + '-meta';
    const new_time = (new Date).toISOString();

    const [old_data, last_time] = await (() => {
        const t = db.transaction([main_name, meta_name], 'readonly');
        return Promise.all([
            idbreq(t.objectStore(main_name), 'getAll'),
            idbreq(t.objectStore(meta_name), 'get', META_KEY),
        ]);
    })();

    const new_data = await fetch_cb(last_time);

    (async () => {
        const t = db.transaction([main_name, meta_name], 'readwrite');
        const os_main = t.objectStore(main_name);
        const os_meta = t.objectStore(meta_name);
        const last_time2 = await idbreq(os_meta, 'get', META_KEY);
        log(table, 'last_time', last_time, 'last_time2', last_time2, 'new_time', new_time);
        if (!last_time2 || last_time2 < new_time) {
            os_meta.put(new_time, META_KEY);
            new_data.forEach(obj => os_main.put(obj));
        }
    })();

    return new Map([...old_data, ...new_data].map(obj => [obj.id, obj]));
}

async function get_data(key, tables) {
    const db = await open_db(key);
    return Promise.all(tables.map(table => get_cached(db, table,
        async function(last_time) {
            const new_data_raw = await query_all(key, table + (last_time ? '?updated_after=' + last_time : ''));
            return new_data_raw.map(({id, object, data}) => {
                data.id = id;
                if (table === 'subjects') {data.type = object;}
                return data
            });
        }
    )));
}




const STAGES = ['Overall', 'Apprentice 1', 'Apprentice 2', 'Apprentice 3', 'Apprentice 4', 'Guru 1', 'Guru 2', 'Master', 'Enlightened', 'Burned'];
async function calculate(key) {
    progress.hidden = false;
    const [subjects, reviews] = await get_data(key, ['subjects', 'reviews']);
    progress.hidden = true;

    const zeros = [0,0,0,0,0,0,0,0,0];
    const counts = {
        radical: {num: [...zeros], den: [...zeros]},
        kanji: {num: [...zeros], den: [...zeros]},
        vocabulary: {num: [...zeros], den: [...zeros]},
    };

    let max_level = 0;
    for (const [id, data] of reviews) {
        const {type, level} = subjects.get(data.subject_id);
        assert(counts[type]);
        max_level = Math.max(max_level, level);

        const srs = data.starting_srs_stage;
        const correct = !(data.incorrect_reading_answers + data.incorrect_meaning_answers);

        counts[type].den[0]++;
        counts[type].den[srs]++;
        if (correct) {
            counts[type].num[0]++;
            counts[type].num[srs]++;
        }
    }

    const out = document.getElementById('results');
    for (const [key, {num, den}] of Object.entries(counts)) {
        out.appendChild(document.createTextNode(`\n${key}:\n`));
        for (let i = 0; i < num.length; ++i) {
            if (!num[i]) {break;}
            const s = `${STAGES[i]}: ${100*num[i]/den[i]}% (${num[i]}/${den[i]})\n`;
            out.appendChild(document.createTextNode(s));
        }
    }
}

document.getElementById('key-input-form').addEventListener('submit', e => {
    e.preventDefault();
    const key = document.getElementById('key-input').value;
    e.target.hidden = true;
    e.target.disabled = true;

    calculate(key).catch(e => {
        error('Caught error', e);
        progress.textContent = 'Oh dear, an error has occured!';
        progress.hidden = false;
    });
}, {once: true});

</script>
